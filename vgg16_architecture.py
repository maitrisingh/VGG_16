# -*- coding: utf-8 -*-
"""VGG16_architecture.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TJCbj_Rl9s5610tmzrSCf41XWb-Rxsi2
"""

import torch
import torch.nn as nn #all neural network module, nn.Linear, nn.Conv2d, BatchNorm, Loss functions
import torch.optim as optim # For all Optimization algorithms, SGD, Adam, etc.
import torch.nn.functional as F # all functions that dont have any parameters
from torch.utils.data import DataLoader # Gives easier dataset management and creates mini batches
import torchvision.datasets as datasets #has standard datasets we can import in convenient way
import torchvision.transforms as transforms #transformation we can perform on our dataset

VGG16 = [64, 64, 'M', 128, 128, 'M', 256, 256, 256, 'M', 512, 512, 512, 'M', 512, 512, 512, 'M']
#then flatten  and 4096x4096x1000 Linear layers

class VGG_net(nn.Module):
  def __int__(self, in_channels = 3, num_classes = 1000):
    super(VGG_net, self).__init__()
    self.in_channels = in_channels
    self.conv_layers = self.create_conv_layers(VGG16)

    self.fcs = nn.Sequential(
        nn.Linear(512*7*7, 4096),
        nn.ReLU(),
        nn.Dropout(p = 0.5),
        nn.Linear(4096, 4096),
        nn.ReLU()
        nn.Dropout(p = 0.5),
        nn.Linear(4096, num_classes)
        
        
    )
  def forward(self, x):
    x = self.conv_layers(x)
    x = x.reshape(x.shape[0], -1)
    x = self.fcs(x)
    return x
    

  def create_conv_layers(self, architecture):
    layers = []
    in_channels = self.in_channels

    for x in architecture:
      if(x) == int:
        out_channels = x

        layers += [nn.Conv2d(in_channels = in_channels, out_channels = out_channels,
                             kernel_size = (3,3), stride = (1,1), padding = (1,1)),
                   nn.BatchNorm2d(x),
                   nn.ReLU()]
        in_channels = x
      elif x == 'M':
        layers += [nn.MaxPool2d(kernel_size = (2,2), stride = (2,2))]  

    return nn.Sequential(*layers)


model = VGG_net(in_channels = 3, num_classes = 1000)
x = torch.randn(1, 3, 224, 224)
print(model(x).shape)